<#
.SYNOPSIS
    --.
.DESCRIPTION
    SetupCustomActions.ps1
    This will setup the Custom Action Scripts used for Feature Updates
.INPUTS
    None.
.OUTPUTS
    None.
.NOTES
    Created by @gwblok
.LINK
    https://garytown.com
.LINK
    https://www.recastsoftware.com
.COMPONENT
    --
.FUNCTIONALITY
    --
#>

## Set script requirements
#Requires -Version 3.0

##*=============================================
##* VARIABLE DECLARATION
##*=============================================
#region VariableDeclaration

$ScriptVersion = "20.12.24.9"

$RunOncePath = "$($env:windir)\System32\update\runonce"
$RunPath = "$($env:windir)\System32\update\run"
$WaaSFolder = "$($env:ProgramData)\WaaS"

#Enable or Disable PowerShell Transcript Logging on this Machine
$PSTranscriptionLogging = $null #Do not Enable or Disable, just leave it alone.

#Logfile generated by this script
$logfile = "$WaaSFolder\CustomActions.log"

#Registry Path that will get Tagged
$registryPath = "HKLM:\SOFTWARE\WaaS"

$RunScriptTable = @(
    @{ Script = "CA_PreInstall"; BatFile = 'preinstall.cmd'; ps1file = 'preinstall.ps1';Type = 'RunOnce'; Path = "$RunOncePath"}
    @{ Script = "CA_PreCommit"; BatFile = 'precommit.cmd'; ps1file = 'precommit.ps1'; Type = 'RunOnce'; Path = "$RunOncePath"}
    @{ Script = "CA_Failure"; BatFile = 'failure.cmd'; ps1file = 'failure.ps1'; Type = 'RunOnce'; Path = "$RunOncePath"}
    @{ Script = "CA_postuninstall"; BatFile = 'postuninstall.cmd'; ps1file = 'postuninstall.ps1'; Type = 'RunOnce'; Path = "$RunOncePath"}
    @{ Script = "CA_success"; BatFile = 'success.cmd'; ps1file = 'success.ps1'; Type = 'RunOnce'; Path = "$RunOncePath"}
    @{ Script = "CA_PreInstall"; BatFile = 'preinstall.cmd'; ps1file = 'preinstall.ps1'; Type = 'Run'; Path = "$RunPath"}
    @{ Script = "CA_PreCommit"; BatFile = 'precommit.cmd'; ps1file = 'precommit.ps1'; Type = 'Run'; Path = "$RunPath"}
    @{ Script = "CA_Failure"; BatFile = 'failure.cmd'; ps1file = 'failure.ps1'; Type = 'Run'; Path = "$RunPath"}
    @{ Script = "CA_postuninstall"; BatFile = 'postuninstall.cmd'; ps1file = 'postuninstall.ps1'; Type = 'Run'; Path = "$RunPath"}
    @{ Script = "CA_success"; BatFile = 'success.cmd'; ps1file = 'success.ps1'; Type = 'Run'; Path = "$RunPath"}
    #@{ Script = "CA_SetupRollBack"; BatFile = 'SetupRollBack.cmd'; ps1file = 'SetupRollBack.ps1'; Type = 'Run'; Path = "$RunPath"}
    #@{ Script = "CA_ErrorHandler"; BatFile = 'ErrorHandler.cmd'; ps1file = 'ErrorHandler.ps1'; Type = 'Run'; Path = "$EventhandlerPath"}
)

#Create a GUID to be used in the Folder
#$ScriptGUID = New-Guid  #Dynamic Generating, cool stuff.. but hard to monitor
$ScriptGUID = "f6b5da3d-d837-49e0-8c10-99dc5e8a3d8d" #Static To make troubleshooting easier
## Get script path and name
[string]$ScriptPath = [System.IO.Path]::GetDirectoryName($MyInvocation.MyCommand.Definition)
[string]$ScriptName = [System.IO.Path]::GetFileNameWithoutExtension($MyInvocation.MyCommand.Definition)

#endregion
##*=============================================
##* END VARIABLE DECLARATION
##*=============================================

##*=============================================
##* FUNCTION LISTINGS
##*=============================================
#region FunctionListings

#region: CMTraceLog Function formats logging in CMTrace style
        function CMTraceLog {
         [CmdletBinding()]
    Param (
		    [Parameter(Mandatory=$false)]
		    $Message,
 
		    [Parameter(Mandatory=$false)]
		    $ErrorMessage,
 
		    [Parameter(Mandatory=$false)]
		    $Component = "CustomActionCreate",
 
		    [Parameter(Mandatory=$false)]
		    [int]$Type,
		
		    [Parameter(Mandatory=$true)]
		    $LogFile
	    )
    <#
    Type: 1 = Normal, 2 = Warning (yellow), 3 = Error (red)
    #>
	    $Time = Get-Date -Format "HH:mm:ss.ffffff"
	    $Date = Get-Date -Format "MM-dd-yyyy"
 
	    if ($ErrorMessage -ne $null) {$Type = 3}
	    if ($Component -eq $null) {$Component = " "}
	    if ($Type -eq $null) {$Type = 1}
 
	    $LogMessage = "<![LOG[$Message $ErrorMessage" + "]LOG]!><time=`"$Time`" date=`"$Date`" component=`"$Component`" context=`"`" type=`"$Type`" thread=`"`" file=`"`">"
	    $LogMessage | Out-File -Append -Encoding UTF8 -FilePath $LogFile
    }

#https://adamtheautomator.com/powershell-logging-recording-and-auditing-all-the-things/
#useful when Troubleshooting the PowerShell Scripts
function Set-PSTranscriptionLogging {
	param(
		[Parameter(Mandatory)]
		[string]$OutputDirectory,
        [Parameter(Mandatory)]		
        [ValidateNotNullOrEmpty()][ValidateSet("Enable", "Disable")][string]$Mode
	)

     # Registry path
     $basePath = 'HKLM:\SOFTWARE\WOW6432Node\Policies\Microsoft\Windows\PowerShell\Transcription'

     # Create the key if it does not exist
     if ($Mode -eq "Enable")
        {
         if(-not (Test-Path $basePath))
         {
             $null = New-Item $basePath -Force

             # Create the correct properties
             New-ItemProperty $basePath -Name "EnableInvocationHeader" -PropertyType Dword
             New-ItemProperty $basePath -Name "EnableTranscripting" -PropertyType Dword
             New-ItemProperty $basePath -Name "OutputDirectory" -PropertyType String
         }

         # These can be enabled (1) or disabled (0) by changing the value
         Set-ItemProperty $basePath -Name "EnableInvocationHeader" -Value "1" -Force -ErrorAction SilentlyContinue
         Set-ItemProperty $basePath -Name "EnableTranscripting" -Value "1" -Force -ErrorAction SilentlyContinue
         Set-ItemProperty $basePath -Name "OutputDirectory" -Value $OutputDirectory -Force -ErrorAction SilentlyContinue
         }
    elseif ($Mode -eq "Disable")
        {
        if(-not (Test-Path $basePath))
            {
             $null = New-Item $basePath -Force

             # Create the correct properties
             New-ItemProperty $basePath -Name "EnableInvocationHeader" -PropertyType Dword
             New-ItemProperty $basePath -Name "EnableTranscripting" -PropertyType Dword
            }

        # These can be enabled (1) or disabled (0) by changing the value
         Set-ItemProperty $basePath -Name "EnableInvocationHeader" -Value "0" -Force -ErrorAction SilentlyContinue
         Set-ItemProperty $basePath -Name "EnableTranscripting" -Value "0" -Force -ErrorAction SilentlyContinue

        }

}
##*=============================================
##* END FUNCTION LISTINGS
##*=============================================

##*=============================================
##* SCRIPT BODY
##*=============================================
#region ScriptBody

#Confirm LogFile Folder
if (!(Test-Path $WaaSFolder)){$NewFolder = new-item -Path $WaaSFolder -ItemType Directory -Force}

#Confirm Registry Path
if (!(Test-Path $registryPath)){$NewKey = New-Item -Path $registryPath -Force}
CMTraceLog -Message  "-----------------------" -Type 2 -LogFile $LogFile



#Write Script Version to Regsitry for Reporting
$RegItem = Get-Item -Path $registryPath
if ($RegItem.GetValue("CustomActionScriptVersion") -ne $Null)
    {
    CMTraceLog -Message  "Script Run Previously, Version: $($RegItem.GetValue("CustomActionScriptVersion"))" -Type 1 -LogFile $LogFile
    }
else
    {
    CMTraceLog -Message  "First Time Script has Run on this Machine" -Type 1 -LogFile $LogFile
    }
CMTraceLog -Message  "Current Script Version: $ScriptVersion" -Type 1 -LogFile $LogFile
Set-ItemProperty -Path $registryPath -Name "CustomActionScriptVersion" -Value $ScriptVersion -Force


CMTraceLog -Message  "Starting $ScriptName" -Type 1 -LogFile $LogFile

#Enable PowerShell Transcripts
if ($PSTranscriptionLogging -eq "Enable")
    {
    CMTraceLog -Message  "Enable PowerShell Transcripts" -Type 1 -LogFile $LogFile
    $PSTranscriptsFolder = "$WaaSFolder\PSTranscripts"
    if (!(Test-Path $PSTranscriptsFolder)){$NewFolder = new-item -Path $PSTranscriptsFolder -ItemType Directory -Force}
    Set-PSTranscriptionLogging -OutputDirectory $PSTranscriptsFolder -Mode Enable
    }

if ($PSTranscriptionLogging -eq "Disable")
    {
    CMTraceLog -Message  "Disable PowerShell Transcripts" -Type 1 -LogFile $LogFile
    $PSTranscriptsFolder = "$WaaSFolder\PSTranscripts"
    if (!(Test-Path $PSTranscriptsFolder)){$NewFolder = new-item -Path $PSTranscriptsFolder -ItemType Directory -Force}
    Set-PSTranscriptionLogging -OutputDirectory $PSTranscriptsFolder -Mode Disable
    }

ForEach ($RunScript in $RunScriptTable)
    {
    Write-Output $RunScript.Script
    CMTraceLog -Message  "Creating: $($RunScript.Path)\$($ScriptGUID)\$($RunScript.batFile)" -Type 1 -LogFile $LogFile

    $BatFilePath = "$($RunScript.Path)\$($ScriptGUID)\$($RunScript.batFile)"
    $PSFilePath = "$($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)\$($RunScript.ps1File)"

        
    #Create Batch File to Call PowerShell File
        
    New-Item -Path $BatFilePath -ItemType File -Force
    
    if ($RunScript.batFile -eq "success.cmd" -and $RunScript.Type -eq "Run") #Add commands to take ownership of wallpaper images to replace later & SetupDiag
        {
        [String]$AdditionalContent = 'cmd.exe /c takeown /f C:\Windows\Web\Screen\*.* & cmd.exe /c icacls C:\Windows\Web\Screen\*.* /Grant System:(F)'
        Add-Content -Path $BatFilePath -Value $AdditionalContent.ToString()
        [String]$AdditionalContent2 = 'cmd.exe /c takeown /f C:\Windows\Web\4K\Wallpaper\Windows\*.* & cmd.exe /c icacls C:\Windows\Web\4K\Wallpaper\Windows\*.* /Grant System:(F) & cmd.exe /c del /q C:\Windows\Web\4K\Wallpaper\Windows\*.*'
        Add-Content -Path $BatFilePath -Value $AdditionalContent2.ToString()
        $CustomActionContent = New-Object system.text.stringbuilder
        [void]$CustomActionContent.Append('start %windir%\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy ByPass -File')
        [void]$CustomActionContent.Append(" $($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)\SuccessSetupDiag.ps1")
        Add-Content -Path $BatFilePath -Value $CustomActionContent.ToString()
        }
    if ($RunScript.batFile -eq "Preinstall.cmd" -and $RunScript.Type -eq "Run") #Adds Command to run Toast
        {
        $CustomActionContent = New-Object system.text.stringbuilder
        [void]$CustomActionContent.Append('start %windir%\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy ByPass -File')
        [void]$CustomActionContent.Append(" $($WaaSFolder)\PreInstall\PreInstallNotificationLauncher.ps1")
        Add-Content -Path $BatFilePath -Value $CustomActionContent.ToString()
        }
    $CustomActionContent = New-Object system.text.stringbuilder
    [void]$CustomActionContent.Append('%windir%\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy ByPass -File')
    [void]$CustomActionContent.Append(" $PSFilePath")
    Add-Content -Path $BatFilePath -Value $CustomActionContent.ToString()



    #Create Blank PowerShell File to do actions
        
    New-Item -Path $PSFilePath -ItemType File -Force

    #For Testing, Tages Registy with time the script ran
    Add-Content -Path $PSFilePath  '$TimeStamp = Get-Date -f s'
    $CustomActionContentPS = New-Object system.text.stringbuilder
    [void]$CustomActionContentPS.Append('$RegistryPath = ') 
    [void]$CustomActionContentPS.Append("""$RegistryPath""")
    Add-Content -Path $PSFilePath -Value $CustomActionContentPS.ToString()
    $CustomActionContentPS = New-Object system.text.stringbuilder
    [void]$CustomActionContentPS.Append('$keyname = ') 
    [void]$CustomActionContentPS.Append("""$($RunScript.Script)_$($RunScript.Type)""")
    Add-Content -Path $PSFilePath -Value $CustomActionContentPS.ToString()
    Add-Content -Path $PSFilePath -Value 'New-ItemProperty -Path $registryPath -Name $keyname -Value $TimeStamp -Force'
    }

#Check for User Provided Custom action Scripts and Copy to correct locations
CMTraceLog -Message  " Checking for User Provided Custom Scripts to Copy" -Type 1 -LogFile $LogFile
if (test-path -Path "$ScriptPath\Run")
    {
    $CustomRunScripts  = Get-ChildItem -Path "$ScriptPath\Run"
    if ($CustomRunScripts)
        {
        foreach ($CustomRunScript in $CustomRunScripts)
            {
        
            if ($CustomRunScript.name -match ".cmd")
                {
                CMTraceLog -Message  "Copying $($CustomRunScript.FullName) to $($RunPath)\$($ScriptGUID)" -Type 1 -LogFile $LogFile
                Copy-Item $CustomRunScript.FullName -Destination "$($RunPath)\$($ScriptGUID)" -Force
                }
            else    
                {
                CMTraceLog -Message  "Copying $($CustomRunScript.FullName) to $($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)" -Type 1 -LogFile $LogFile
                Copy-Item $CustomRunScript.FullName -Destination "$($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)" -Force   
                }
            }
        }
    else
        {
        CMTraceLog -Message  "No User Provided Custom Action Scripts to Copy (Run)" -Type 1 -LogFile $LogFile
        }
    }
else
    {
    CMTraceLog -Message  "No User Provided Custom Action Scripts to Copy (Run)" -Type 1 -LogFile $LogFile
    }
if (test-path -Path "$ScriptPath\RunOnce")
    {
    $CustomRunOnceScripts  = Get-ChildItem -Path "$ScriptPath\RunOnce"
    if ($CustomRunOnceScripts)
        {
        foreach ($CustomRunOnceScript in $CustomRunOnceScripts)
            {
            if ($CustomRunOnceScript.name -match ".cmd")
                {
                CMTraceLog -Message  "Copying $($CustomRunOnceScript.FullName) to $($RunPath)\$($ScriptGUID)" -Type 1 -LogFile $LogFile
                Copy-Item $CustomRunOnceScript.FullName -Destination "$($RunOncePath)\$($ScriptGUID)" -Force
                }
            else    
                {
                CMTraceLog -Message  "Copying $($CustomRunOnceScript.FullName) to $($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)" -Type 1 -LogFile $LogFile
                Copy-Item $CustomRunOnceScript.FullName -Destination "$($WaaSFolder)\$($RunScript.Type)\$($ScriptGUID)" -Force   
                }
            }
        }
    else
        {
        CMTraceLog -Message  "No User Provided Custom Action Scripts to Copy (RunOnce)" -Type 1 -LogFile $LogFile
        }
    }
else
    {
    CMTraceLog -Message  "No User Provided Custom Action Scripts to Copy (RunOnce)" -Type 1 -LogFile $LogFile
    }


CMTraceLog -Message  "Checking for Provided files that will be used during Success" -Type 1 -LogFile $LogFile
if (Test-Path -Path "$ScriptPath\Success")
    {
    CMTraceLog -Message  " Found Success Files" -Type 1 -LogFile $LogFile
    $SuccessFiles  = Get-ChildItem -Path "$ScriptPath\Success" -Recurse  | Where-Object {$_.name -like "*.???" }
    foreach ($SuccessFile in $SuccessFiles)
        {
        $Destination = "$WaaSFolder$(($SuccessFile.FullName).replace($ScriptPath, ''))"
        $DestinationFolder = Split-Path -Path $Destination
        if (!(Test-Path -Path $DestinationFolder)){$SuccessFolder = New-Item -Path $DestinationFolder -ItemType Directory -Force}
        CMTraceLog -Message  "Copying $($SuccessFile.FullName) to $Destination" -Type 1 -LogFile $LogFile
        Copy-Item $SuccessFile.FullName -Destination $Destination -Force
        }
    }
else
    {
    CMTraceLog -Message  " No Success Files Found" -Type 1 -LogFile $LogFile
    }

CMTraceLog -Message  "Checking for Provided files that will be used during Preinstall" -Type 1 -LogFile $LogFile
if (Test-Path -Path "$ScriptPath\Preinstall")
    {
    CMTraceLog -Message  " Found Preinstall Files" -Type 1 -LogFile $LogFile
    $PreinstallFiles  = Get-ChildItem -Path "$ScriptPath\Preinstall" -Recurse  | Where-Object {$_.name -like "*.???" }
    foreach ($PreintallFile in $PreinstallFiles)
        {
        $Destination = "$WaaSFolder$(($PreintallFile.FullName).replace($ScriptPath, ''))"
        $DestinationFolder = Split-Path -Path $Destination
        if (!(Test-Path -Path $DestinationFolder)){$PreinstallFolder = New-Item -Path $DestinationFolder -ItemType Directory -Force}
        CMTraceLog -Message  "Copying $($PreintallFile.FullName) to $Destination" -Type 1 -LogFile $LogFile
        Copy-Item $PreintallFile.FullName -Destination $Destination -Force
        }
    }
else
    {
    CMTraceLog -Message  " No Preinstall Files Found" -Type 1 -LogFile $LogFile
    }

#Grant rights to all users on the box to be able to write to the log file.
# Create the ACE
$identity = 'BUILTIN\users'
$rights = 'Modify' #Other options: [enum]::GetValues('System.Security.AccessControl.FileSystemRights')
$type = 'Allow' #Other options: [enum]::GetValues('System.Securit y.AccessControl.AccessControlType')
$ACE = New-Object System.Security.AccessControl.FileSystemAccessRule($identity,$rights,$type)
#Apply the Updated Permissions to log file
$Acl = Get-Acl -Path $logfile
$Acl.AddAccessRule($ACE)
Set-Acl -Path $logfile -AclObject $Acl
CMTraceLog -Message  "Added Modify Rights to BUILTIN\USERS on the logfile" -Type 1 -LogFile $LogFile

CMTraceLog -Message  "Finished $ScriptName" -Type 1 -LogFile $LogFile
exit $exitcode
#endregion
##*=============================================
##* END SCRIPT BODY
##*=============================================