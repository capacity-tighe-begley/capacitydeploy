<#
.SYNOPSIS
    --.
.DESCRIPTION
    Preinstall.ps1, triggered by preinstall.cmd
    Application Checking PreFlight script to confirm some applications are at specific levels, or the script will fail the upgrade out early, making reporting easier.

    Update the $AppChecks variable to check for additional apps. Add as many versions as you want to "Approve" to be allowed
.INPUTS
    None.
.OUTPUTS
    None.
.NOTES
    Created by @gwblok
.LINK
    https://garytown.com
.LINK
    https://www.recastsoftware.com
.COMPONENT
    --
.FUNCTIONALITY
    --
#>

## Set script requirements
#Requires -Version 3.0

##*=============================================
##* VARIABLE DECLARATION
##*=============================================
#region VariableDeclaration

#Registry Path that will get Tagged
$registryPath = "HKLM:\SOFTWARE\WaaS"
$TimeStamp = Get-Date -f s
$keyname = "CA_PreInstall_Run"
New-ItemProperty -Path $registryPath -Name $keyname -Value $TimeStamp -Force

#Check for these Installed Applications and make sure they match these versions, or the script will exit with error
$AppChecks = @(

@{ AppName = "GreenShot%"; Version = ("1.3.10.6","1.2.10.6")}
@{ AppName = "Dell Command | Monitor"; Version = ("10.3.1.138")}
@{ AppName = "7-zip%"; Version = ("20.00")}
@{ AppName = "OBS Studio"; Version = ("25.0.8")}
)

#Logfile generated by this script
$WaaSFolder = "$($env:ProgramData)\WaaS"
$logfile = "$WaaSFolder\CustomActions.log"

## Get script path and name
[string]$ScriptPath = [System.IO.Path]::GetDirectoryName($MyInvocation.MyCommand.Definition)
[string]$ScriptName = [System.IO.Path]::GetFileNameWithoutExtension($MyInvocation.MyCommand.Definition)

#endregion
##*=============================================
##* END VARIABLE DECLARATION
##*=============================================

##*=============================================
##* FUNCTION LISTINGS
##*=============================================
#region FunctionListings

#region: CMTraceLog Function formats logging in CMTrace style
        function CMTraceLog {
         [CmdletBinding()]
    Param (
		    [Parameter(Mandatory=$false)]
		    $Message,
 
		    [Parameter(Mandatory=$false)]
		    $ErrorMessage,
 
		    [Parameter(Mandatory=$false)]
		    $Component = "PreInstall",
 
		    [Parameter(Mandatory=$false)]
		    [int]$Type,
		
		    [Parameter(Mandatory=$true)]
		    $LogFile
	    )
    <#
    Type: 1 = Normal, 2 = Warning (yellow), 3 = Error (red)
    #>
	    $Time = Get-Date -Format "HH:mm:ss.ffffff"
	    $Date = Get-Date -Format "MM-dd-yyyy"
 
	    if ($ErrorMessage -ne $null) {$Type = 3}
	    if ($Component -eq $null) {$Component = " "}
	    if ($Type -eq $null) {$Type = 1}
 
	    $LogMessage = "<![LOG[$Message $ErrorMessage" + "]LOG]!><time=`"$Time`" date=`"$Date`" component=`"$Component`" context=`"`" type=`"$Type`" thread=`"`" file=`"`">"
	    $LogMessage | Out-File -Append -Encoding UTF8 -FilePath $LogFile
    }


#https://adamtheautomator.com/powershell-logging-recording-and-auditing-all-the-things/
function Enable-PSTranscriptionLogging {
	param(
		[Parameter(Mandatory)]
		[string]$OutputDirectory
	)

     # Registry path
     $basePath = 'HKLM:\SOFTWARE\WOW6432Node\Policies\Microsoft\Windows\PowerShell\Transcription'

     # Create the key if it does not exist
     if(-not (Test-Path $basePath))
     {
         $null = New-Item $basePath -Force

         # Create the correct properties
         New-ItemProperty $basePath -Name "EnableInvocationHeader" -PropertyType Dword
         New-ItemProperty $basePath -Name "EnableTranscripting" -PropertyType Dword
         New-ItemProperty $basePath -Name "OutputDirectory" -PropertyType String
     }

     # These can be enabled (1) or disabled (0) by changing the value
     Set-ItemProperty $basePath -Name "EnableInvocationHeader" -Value "1"
     Set-ItemProperty $basePath -Name "EnableTranscripting" -Value "1"
     Set-ItemProperty $basePath -Name "OutputDirectory" -Value $OutputDirectory

}
##*=============================================
##* END FUNCTION LISTINGS
##*=============================================

##*=============================================
##* SCRIPT BODY
##*=============================================
#region ScriptBody


#Confirm LogFile Folder
if (!(Test-Path $WaaSFolder)){$NewFolder = new-item -Path $WaaSFolder -ItemType Directory -Force}
CMTraceLog -Message  "------------------------------" -Type 1 -LogFile $LogFile
CMTraceLog -Message  "Starting $ScriptName" -Type 1 -LogFile $LogFile

#Enable PowerShell Transcripts
CMTraceLog -Message  "Enable PowerShell Transcripts" -Type 1 -LogFile $LogFile
$PSTranscriptsFolder = "$WaaSFolder\PSTranscripts"
if (!(Test-Path $PSTranscriptsFolder)){$NewFolder = new-item -Path $PSTranscriptsFolder -ItemType Directory -Force}
Enable-PSTranscriptionLogging -OutputDirectory $PSTranscriptsFolder



ForEach ($AppCheck in $AppChecks)
    {
    $CurrentAppVersion = $null
    $CurrentAppVersion = [system.version](Get-WmiObject -Namespace 'root\cimv2\sms' -Query "SELECT ProductVersion FROM SMS_InstalledSoftware where ARPDisplayName like '$($AppCheck.AppName)'").ProductVersion
    [system.version[]]$CurrentAppRequiredVersion = ($AppCheck.Version)
    if ($CurrentAppVersion)
        {
        if ($CurrentAppVersion -in $CurrentAppRequiredVersion)
            {
            Write-Output "Found: $($AppCheck.AppName) with Correct Version: $CurrentAppVersion"
            CMTraceLog -Message  "Found: $($AppCheck.AppName) with Correct Version: $CurrentAppVersion" -Type 1 -LogFile $LogFile
            }
        else
            {
            Write-Output "Found: $($AppCheck.AppName) - WRONG Version!! - Needs: $($AppCheck.Version) | Has: $CurrentAppVersion"
            CMTraceLog -Message  "Found: $($AppCheck.AppName) - WRONG Version!! - Needs: $($AppCheck.Version) | Has: $CurrentAppVersion" -Type 3 -LogFile $LogFile
            $exitcode = "253"
            }
        }
    else
        {
        Write-Output "Not Found: App $($AppCheck.AppName)"
        CMTraceLog -Message  "Not Found: App $($AppCheck.AppName)" -Type 1 -LogFile $LogFile
        }
    }
if ($ExitCode){CMTraceLog -Message  "Exit Code: $ExitCode" -Type 1 -LogFile $LogFile}
CMTraceLog -Message  "Finished $ScriptName" -Type 1 -LogFile $LogFile
exit $exitcode
#endregion
##*=============================================
##* END SCRIPT BODY
##*=============================================